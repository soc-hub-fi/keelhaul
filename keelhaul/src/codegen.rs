//! Generate test cases from types implementing [`TestRegister`]

// Public API
pub use self::test_memory::MemTestStrategy;

// Internal codegen API
pub(crate) use self::test_memory::gen_memtest_module;
pub(crate) use self::test_register::{RegTestCases, TestRegister, ValueOnReset};

mod test_memory;
mod test_register;

use std::{any, cmp, collections::HashSet, fmt, iter, str};

use crate::{model, TestKind};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use strum::IntoEnumIterator;

/// Generate module description including generator version string and timestamp
fn gen_mod_desc() -> String {
    let crate_name = env!("CARGO_CRATE_NAME");
    let version = env!("CARGO_PKG_VERSION");
    let utc = chrono::Utc::now();
    let timestamp = utc.to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

    format!("Generated by {crate_name} v{version} at {timestamp}")
}

/// # Arguments
///
/// * `widest` - Size of the widest register on platform, capable of containing the bits of any
///   register on platform.
fn gen_error_struct(widest: u32, error_derive_debug: bool) -> TokenStream {
    // It costs a lot of code size to `#[derive(Debug)]` so we do it only if required
    let derives = if error_derive_debug {
        quote!(#[derive(Debug)])
    } else {
        quote!()
    };

    let max_reg_t = format_ident!("{}", bit_count_to_rust_uint_type_str(widest));

    // Generate an error variant for all test case kinds
    let error_variant_defs: TokenStream = TestKind::iter()
        .filter_map(|test_kind| {
            match test_kind {
                TestKind::Read => None,
                TestKind::ReadIsResetVal => Some(
                    // We try to avoid generating extra code as much as possible. Therefore we only
                    // reference existing static symbols or integers here.
                    quote! {
                        /// The read value was not the expected value on reset
                        ///
                        /// This means that the source file (IP-XACT or SVD) claims that the register
                        /// value on reset should be `reset_val` but it was `read_val` instead.
                        ReadValueIsNotResetValue {
                            /// The value that was read from the register
                            read_val: #max_reg_t,
                            /// Expected value for this register on reset
                            reset_val: #max_reg_t,
                            /// Register identifier or "full path"
                            reg_uid: &'static str,
                            /// Register address
                            reg_addr: usize,
                        },
                    },
                ),
            }
        })
        .collect();

    quote! {
        #derives
        pub enum Error {
            #error_variant_defs
        }
    }
}

/// Generate preamble including doc string and imports
///
/// # Arguments
///
/// * `widest` - Size of the widest register on platform, capable of containing the bits of any
///   register on platform.
fn gen_preamble(widest: u32, error_derive_debug: bool) -> TokenStream {
    let mod_doc = gen_mod_desc();

    let error_struct = gen_error_struct(widest, error_derive_debug);

    quote! {
        // Module documentation is provided via `_DOC` symbol. Do not use inner attributes in
        // generated code: https://github.com/rust-lang/rfcs/issues/752
        #[doc = #mod_doc]
        const _DOC: () = ();

        use core::ptr::*;

        #error_struct

        pub type Result<T> = core::result::Result<T, Error>;

        /// Represents a test case for a single register.
        pub struct TestCase<'a> {
            pub function: fn() -> Result<()>,
            pub addr: usize,
            pub uid: &'a str,
        }
    }
}

#[derive(Clone, Debug)]
pub enum FailureImplKind {
    None,
    Panic,
    ReturnError,
}

#[derive(Clone, Debug)]
pub struct CodegenConfig {
    /// What types of tests to generate
    ///
    /// [RegTestKind::Read]: read register value (may cause e.g., bus failure or hang)
    /// [RegTestKind::Reset]: read register value and verify it matches with reset value
    tests_to_generate: HashSet<TestKind>,
    /// What to do on failure:
    ///
    /// [FailureImplementation::ReturnValue]: just return the possibly incorrect value
    /// [FailureImplementation::Panic]: panic on failure (e.g., through assert)
    on_fail: FailureImplKind,
    /// Generate `#[derive(Debug)]` for types such as Error
    derive_debug: bool,
    /// Ignore reset masks when checking for reset value match
    ///
    /// This is useful because sometimes the people who make SVDs make all the
    /// reset masks zeros and we need to ignore them.
    force_ignore_reset_mask: bool,
}

impl Default for CodegenConfig {
    fn default() -> Self {
        Self {
            tests_to_generate: iter::once(TestKind::Read).collect(),
            on_fail: FailureImplKind::ReturnError,
            derive_debug: false,
            // HACK: set to true on defautl while Headsail's reset masks are broken
            force_ignore_reset_mask: true,
        }
    }
}

impl CodegenConfig {
    /// Get test kinds
    ///
    /// # Errors
    ///
    /// - Read test was not enabled while reset test was
    pub fn tests_to_generate(
        mut self,
        tests_to_generate: HashSet<TestKind>,
    ) -> Result<Self, String> {
        if tests_to_generate.contains(&TestKind::ReadIsResetVal)
            && !tests_to_generate.contains(&TestKind::Read)
        {
            return Err(
                "enabling of reset test requires read test to be enabled as well".to_owned(),
            );
        }
        self.tests_to_generate = tests_to_generate;
        Ok(self)
    }

    /// TODO
    ///
    /// # Errors
    ///
    /// - TODO
    pub fn on_fail(mut self, on_fail: FailureImplKind) -> Self {
        self.on_fail = on_fail;
        self
    }

    pub fn derive_debug(mut self, derive_debug: bool) -> Self {
        self.derive_debug = derive_debug;
        self
    }

    pub fn ignore_reset_masks(mut self, ignore_reset_masks: bool) -> Self {
        self.force_ignore_reset_mask = ignore_reset_masks;
        self
    }
}

/// Generates a "bitwise and" operation for given value and mask
///
/// # Examples
///
/// `val = 0xb0`, `mask = u8::MAX` -> `0xb0u8`
/// `val = 0xb0`, `mask = 1` ->  `(0xb0u8 & 0b1u8)`
fn gen_bitand<T: model::BitSized<T> + fmt::LowerHex + fmt::Binary + cmp::PartialOrd>(
    value: T,
    mask: T,
) -> TokenStream {
    let value_lit = u_to_hexlit(value, T::bit_count());

    match mask {
        mask if mask == T::all_ones() => {
            quote!(#value_lit)
        }
        mask => {
            let mask_bin = u_to_binlit(mask, T::bit_count());
            quote! {
                (#value_lit & #mask_bin)
            }
        }
    }
}

/// Get a literal hexadecimal representation of `val`, e.g., "0xdeadbeef"
fn u_to_hexlit<T: fmt::LowerHex + cmp::PartialOrd + model::BitSized<T>>(
    val: T,
    bits: u32,
) -> TokenStream {
    assert!(
        T::can_represent(val),
        "value `{val:?}` cannot be represented using `{}`",
        any::type_name::<T>()
    );
    match bits {
        8 => format!("{val:#x}u8"),
        16 => format!("{val:#x}u16"),
        32 => format!("{val:#x}u32"),
        64 => format!("{val:#x}u64"),
        b => panic!("invalid bit count for literal: {b}"),
    }
    .parse()
    .unwrap()
}

/// Get a literal binary representation of `val`, e.g., "0b10101010"
fn u_to_binlit<T: fmt::Binary + cmp::PartialOrd + model::BitSized<T>>(
    val: T,
    bits: u32,
) -> TokenStream {
    assert!(
        T::can_represent(val),
        "value `{val:?}` cannot be represented using `{}`",
        any::type_name::<T>()
    );
    match bits {
        8 => format!("{val:#b}u8"),
        16 => format!("{val:#b}u16"),
        32 => format!("{val:#b}u32"),
        64 => format!("{val:#b}u64"),
        b => panic!("invalid bit count for literal: {b}"),
    }
    .parse()
    .unwrap()
}

#[test]
fn reset_value_bitands_generate() {
    use crate::codegen::gen_bitand;

    assert_eq!(gen_bitand(0xb0, u8::MAX).to_string(), "0xb0u8");
    assert_eq!(
        gen_bitand(0xb0, 0b0000_0001u8).to_string(),
        "(0xb0u8 & 0b1u8)"
    );
    assert_eq!(
        gen_bitand(0xb0, 0b0000_0010u8).to_string(),
        "(0xb0u8 & 0b10u8)"
    );
    assert_eq!(
        gen_bitand(0xdead_beef, 0b0101_0101u32).to_string(),
        "(0xdeadbeefu32 & 0b1010101u32)"
    );
    assert_eq!(
        gen_bitand(0xdead_beef, u32::MAX).to_string(),
        "0xdeadbeefu32"
    );
    assert_eq!(
        gen_bitand(0xdead_beef_cafe_f00d, u64::MAX).to_string(),
        "0xdeadbeefcafef00du64"
    );
}

pub(crate) fn bit_count_to_rust_uint_type_str(bit_count: u32) -> &'static str {
    match bit_count {
        8 => "u8",
        16 => "u16",
        32 => "u32",
        64 => "u64",
        _ => panic!("{bit_count} is not a valid bit count"),
    }
}
